package e2e

import (
	"bytes"
	"io"
	"os"
	"path/filepath"
	"testing"

	"github.com/stretchr/testify/require"

	"github.com/joshuapare/hivekit/hive"
)

// ---- Integration test table model ----

type regfExpect struct {
	// If non-nil, ParseBaseBlock must fail and contain this substring.
	ParseErrSubstr *string
	// If non-nil, Validate must fail and contain this substring.
	ValidateErrSubstr *string

	// Optional field checks (nil => skip assertion)
	Clean        *bool // Sequence1==Sequence2
	ChecksumOK   *bool
	Major        *uint32
	Minor        *uint32
	RootCellRel  *uint32
	DataSize     *uint32
	Flags        *uint32
	PendingTx    *bool
	Differencing *bool

	// FileName prefix match (raw 64-byte header field)
	FileNamePrefix *string
	// Optional expected GUIDSignature value (0x0A4)
	GUIDSignature *uint32
}

type regfCase struct {
	// Path can be absolute or relative. If not absolute, we also try under ./testdata/
	Path    string
	Expect  regfExpect
	Comment string // docs only
	// Run on short tests - suites should not since they may not be available
	Short bool
}

func TestREGF_EndToEnd_FromFiles(t *testing.T) {
	parseErr := func(s string) *string { return &s }
	bptr := func(b bool) *bool { return &b }
	uptr := func(u uint32) *uint32 { return &u }
	sptr := func(s string) *string { return &s }

	cases := map[string]regfCase{
		// ===== Known-good samples (suite) =====
		// Generated by scripts/extract_header_info.go

		"2003-server-software": {
			Path: filepath.Join("testdata", "suite", "windows-2003-server-software"),
			Expect: regfExpect{
				Clean:          bptr(true),
				ChecksumOK:     bptr(true),
				Major:          uptr(1),
				Minor:          uptr(5),
				RootCellRel:    uptr(0x20),
				DataSize:       uptr(0xF34000),
				Flags:          uptr(0x0),
				PendingTx:      bptr(false),
				Differencing:   bptr(false),
				FileNamePrefix: sptr("e"),
				GUIDSignature:  uptr(0x00000000),
			},
			Comment: "Windows Server 2003 SOFTWARE hive (version 1.5)",
		},

		"2003-server-system": {
			Path: filepath.Join("testdata", "suite", "windows-2003-server-system"),
			Expect: regfExpect{
				Clean:          bptr(true),
				ChecksumOK:     bptr(true),
				Major:          uptr(1),
				Minor:          uptr(5),
				RootCellRel:    uptr(0x20),
				DataSize:       uptr(0x1E6000),
				Flags:          uptr(0x0),
				PendingTx:      bptr(false),
				Differencing:   bptr(false),
				FileNamePrefix: sptr("S"),
				GUIDSignature:  uptr(0x00000000),
			},
			Comment: "Windows Server 2003 SYSTEM hive (version 1.5)",
		},

		"2012-software": {
			Path: filepath.Join("testdata", "suite", "windows-2012-software"),
			Expect: regfExpect{
				Clean:          bptr(true),
				ChecksumOK:     bptr(true),
				Major:          uptr(1),
				Minor:          uptr(5),
				RootCellRel:    uptr(0x20),
				DataSize:       uptr(0x223F000),
				Flags:          uptr(0x0),
				PendingTx:      bptr(false),
				Differencing:   bptr(false),
				FileNamePrefix: sptr("e"),
				GUIDSignature:  uptr(0x6D746D72),
			},
			Comment: "Windows Server 2012 SOFTWARE hive (version 1.5)",
		},

		"2012-system": {
			Path: filepath.Join("testdata", "suite", "windows-2012-system"),
			Expect: regfExpect{
				Clean:          bptr(true),
				ChecksumOK:     bptr(true),
				Major:          uptr(1),
				Minor:          uptr(5),
				RootCellRel:    uptr(0x20),
				DataSize:       uptr(0x8E3000),
				Flags:          uptr(0x0),
				PendingTx:      bptr(false),
				Differencing:   bptr(false),
				FileNamePrefix: sptr("S"),
				GUIDSignature:  uptr(0x6D746D72),
			},
			Comment: "Windows Server 2012 SYSTEM hive (version 1.5)",
		},

		"8-cp-software": {
			Path: filepath.Join("testdata", "suite", "windows-8-consumer-preview-software"),
			Expect: regfExpect{
				Clean:          bptr(true),
				ChecksumOK:     bptr(true),
				Major:          uptr(1),
				Minor:          uptr(5),
				RootCellRel:    uptr(0x20),
				DataSize:       uptr(0x26A1000),
				Flags:          uptr(0x1),
				PendingTx:      bptr(true),
				Differencing:   bptr(false),
				FileNamePrefix: sptr("e"),
				GUIDSignature:  uptr(0x6D746D72),
			},
			Comment: "Windows 8 Consumer Preview SOFTWARE hive (version 1.5)",
		},

		"8-cp-system": {
			Path: filepath.Join("testdata", "suite", "windows-8-consumer-preview-system"),
			Expect: regfExpect{
				Clean:          bptr(true),
				ChecksumOK:     bptr(true),
				Major:          uptr(1),
				Minor:          uptr(5),
				RootCellRel:    uptr(0x20),
				DataSize:       uptr(0x687000),
				Flags:          uptr(0x1),
				PendingTx:      bptr(true),
				Differencing:   bptr(false),
				FileNamePrefix: sptr("S"),
				GUIDSignature:  uptr(0x6D746D72),
			},
			Comment: "Windows 8 Consumer Preview SYSTEM hive (version 1.5)",
		},

		"8-ent-software": {
			Path: filepath.Join("testdata", "suite", "windows-8-enterprise-software"),
			Expect: regfExpect{
				Clean:          bptr(true),
				ChecksumOK:     bptr(true),
				Major:          uptr(1),
				Minor:          uptr(5),
				RootCellRel:    uptr(0x20),
				DataSize:       uptr(0x1810000),
				Flags:          uptr(0x0),
				PendingTx:      bptr(false),
				Differencing:   bptr(false),
				FileNamePrefix: sptr("e"),
				GUIDSignature:  uptr(0x6D746D72),
			},
			Comment: "Windows 8 Enterprise SOFTWARE hive (version 1.5)",
		},

		"8-ent-system": {
			Path: filepath.Join("testdata", "suite", "windows-8-enterprise-system"),
			Expect: regfExpect{
				Clean:          bptr(true),
				ChecksumOK:     bptr(true),
				Major:          uptr(1),
				Minor:          uptr(5),
				RootCellRel:    uptr(0x20),
				DataSize:       uptr(0x67F000),
				Flags:          uptr(0x0),
				PendingTx:      bptr(false),
				Differencing:   bptr(false),
				FileNamePrefix: sptr("S"),
				GUIDSignature:  uptr(0x6D746D72),
			},
			Comment: "Windows 8 Enterprise SYSTEM hive (version 1.5)",
		},

		"xp-2-software": {
			Path: filepath.Join("testdata", "suite", "windows-xp-2-software"),
			Expect: regfExpect{
				Clean:          bptr(true),
				ChecksumOK:     bptr(true),
				Major:          uptr(1),
				Minor:          uptr(5),
				RootCellRel:    uptr(0x20),
				DataSize:       uptr(0x8CF000),
				Flags:          uptr(0x310066),
				PendingTx:      bptr(false),
				Differencing:   bptr(true),
				FileNamePrefix: sptr("e"),
				GUIDSignature:  uptr(0x00380038),
			},
			Comment: "Windows XP SOFTWARE hive (version 1.5)",
		},

		"xp-2-system": {
			Path: filepath.Join("testdata", "suite", "windows-xp-2-system"),
			Expect: regfExpect{
				Clean:          bptr(true),
				ChecksumOK:     bptr(true),
				Major:          uptr(1),
				Minor:          uptr(5),
				RootCellRel:    uptr(0x20),
				DataSize:       uptr(0x2E2000),
				Flags:          uptr(0x22203D20),
				PendingTx:      bptr(false),
				Differencing:   bptr(false),
				FileNamePrefix: sptr("S"),
				GUIDSignature:  uptr(0x203D2065),
			},
			Comment: "Windows XP SYSTEM hive (version 1.5)",
		},

		"xp-software": {
			Path: filepath.Join("testdata", "suite", "windows-xp-software"),
			Expect: regfExpect{
				Clean:          bptr(true),
				ChecksumOK:     bptr(true),
				Major:          uptr(1),
				Minor:          uptr(5),
				RootCellRel:    uptr(0x20),
				DataSize:       uptr(0x2C6000),
				Flags:          uptr(0x0),
				PendingTx:      bptr(false),
				Differencing:   bptr(false),
				FileNamePrefix: sptr("S"),
				GUIDSignature:  uptr(0x00000000),
			},
			Comment: "Windows XP SOFTWARE hive (version 1.5)",
		},

		"xp-system": {
			Path: filepath.Join("testdata", "suite", "windows-xp-system"),
			Expect: regfExpect{
				Clean:          bptr(true),
				ChecksumOK:     bptr(true),
				Major:          uptr(1),
				Minor:          uptr(5),
				RootCellRel:    uptr(0x20),
				DataSize:       uptr(0x67F000),
				Flags:          uptr(0x0),
				PendingTx:      bptr(false),
				Differencing:   bptr(false),
				FileNamePrefix: sptr("S"),
				GUIDSignature:  uptr(0x6D746D72),
			},
			Comment: "Windows XP SYSTEM hive (version 1.5)",
		},

		// ===== Corrupted samples =====
		"corrupt-regf-signature": {
			Short: true,
			Path:  filepath.Join("testdata", "corrupted", "corrupt_regf_signature"),
			Expect: regfExpect{
				ParseErrSubstr: parseErr("bad REGF signature"),
			},
		},
		"corrupt-regf-truncated": {
			Short: true,
			Path:  filepath.Join("testdata", "corrupted", "corrupt_regf_truncated"),
			Expect: regfExpect{
				ParseErrSubstr: parseErr("file too small"),
			},
		},
		"corrupt-regf-sequence-mismatch": {
			Short: true,
			Path:  filepath.Join("testdata", "corrupted", "corrupt_regf_sequence_mismatch"),
			Expect: regfExpect{
				// Dirty hive is not a validation error; we just assert Clean=false
				ChecksumOK: bptr(true),
				Clean:      bptr(false),
			},
		},
		"corrupt-nk-signature": {
			Short: true,
			Path:  filepath.Join("testdata", "corrupted", "corrupt_nk_signature"),
			Expect: regfExpect{
				ChecksumOK: bptr(true), // header OK; NK fails elsewhere
			},
		},
	}

	for name, tc := range cases {
		t.Run(name, func(t *testing.T) {
			if testing.Short() && !tc.Short {
				t.Skip()
			}

			raw, err := loadHiveFile(tc.Path)
			require.NoError(t, err, "unable to read %s", tc.Path)

			bb, perr := hive.ParseBaseBlock(raw)
			if tc.Expect.ParseErrSubstr != nil {
				require.Error(t, perr, "ParseBaseBlock should have failed")
				require.Contains(t, perr.Error(), *tc.Expect.ParseErrSubstr)
				return
			}
			require.NoError(t, perr, "ParseBaseBlock failed unexpectedly")

			// Quick checks
			if tc.Expect.ChecksumOK != nil {
				require.Equal(t, *tc.Expect.ChecksumOK, bb.ChecksumOK(), "ChecksumOK mismatch")
			}
			if tc.Expect.Clean != nil {
				require.Equal(t, *tc.Expect.Clean, bb.IsClean(), "IsClean mismatch")
			}

			// Validate against file size
			verr := bb.Validate(len(raw))
			if tc.Expect.ValidateErrSubstr != nil {
				require.Error(t, verr, "Validate should have failed")
				require.Contains(t, verr.Error(), *tc.Expect.ValidateErrSubstr)
				return
			}
			require.NoError(t, verr, "Validate failed unexpectedly")

			// Field assertions (only those provided)
			if tc.Expect.Major != nil {
				require.Equal(t, *tc.Expect.Major, bb.Major(), "Major mismatch")
			}
			if tc.Expect.Minor != nil {
				require.Equal(t, *tc.Expect.Minor, bb.Minor(), "Minor mismatch")
			}
			if tc.Expect.RootCellRel != nil {
				require.Equal(
					t,
					*tc.Expect.RootCellRel,
					bb.RootCellOffset(),
					"RootCellRel mismatch",
				)
			}
			if tc.Expect.DataSize != nil {
				require.Equal(t, *tc.Expect.DataSize, bb.DataSize(), "DataSize mismatch")
			}
			if tc.Expect.Flags != nil {
				require.Equal(t, *tc.Expect.Flags, bb.Flags(), "Flags mismatch")
			}
			if tc.Expect.PendingTx != nil {
				require.Equal(
					t,
					*tc.Expect.PendingTx,
					bb.HasPendingTransactions(),
					"PendingTx flag mismatch",
				)
			}
			if tc.Expect.Differencing != nil {
				require.Equal(
					t,
					*tc.Expect.Differencing,
					bb.IsDifferencingHive(),
					"Differencing flag mismatch",
				)
			}
			if tc.Expect.FileNamePrefix != nil {
				fn := bb.FileName()
				require.True(
					t,
					bytes.HasPrefix(fn, []byte(*tc.Expect.FileNamePrefix)),
					"FileName prefix %q not found in %q",
					*tc.Expect.FileNamePrefix,
					string(bytes.TrimRight(fn, "\x00")),
				)
			}
			if tc.Expect.GUIDSignature != nil {
				require.Equal(
					t,
					*tc.Expect.GUIDSignature,
					bb.GUIDSignature(),
					"GUIDSignature mismatch",
				)
			}
		})
	}
}

// ---- Helpers ----

func loadHiveFile(p string) ([]byte, error) {
	// try as provided
	if b, err := os.ReadFile(filepath.Join("..", "..", p)); err == nil {
		return b, nil
	}
	// last attempt: open and stream (for very large files)
	f, err := os.Open(p)
	if err != nil {
		return nil, err
	}
	defer f.Close()
	return io.ReadAll(f)
}
